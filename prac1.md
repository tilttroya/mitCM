# Практическое занятие №1. Введение, основы работы в командной строке

## **Задание №1**
```bash
grep '.*' /etc/passwd | cut -d: -f1 | sort
```

```bash
adm
at
bin
cron
cyrus
daemon
dhcp
ftp
games
guest
halt
lp
mail
man
news
nobody
ntp
operator
postmaster
root
shutdown
smmsp
squid
sshd
svn
sync
uucp
vpopmail
xfs
```

`grep '.*' /etc/passwd`: Эта команда выводит все строки из файла `/etc/passwd`. Шаблон `'.*'` в grep означает "любой текст", и по сути, это эквивалент просто вывода всего содержимого файла.

`cut -d: -f1`: Команда cut разделяет строки по указанному разделителю (в данном случае :) и выводит только первую часть строки. Разделителем является двоеточие (:), и первая часть строки — это имя пользователя. Таким образом, `cut -d: -f1` выводит список всех имен пользователей.

`sort`: Эта команда сортирует строки по алфавиту.

## **Задание №2**
```bash
awk '{print $2, $1}' /etc/protocols | sort -nr | head -n 5
```

`awk` - в данном случае он читает строки из файла `/etc/protocols` и выводит значения из двух полей: второе поле выводится первым, а первое — вторым.

`sort -nr` сортирует строки по числовому значению (ключ `-n`) в обратном порядке (ключ `-r`). Это значит, что строки будут отсортированы по убыванию значений номеров протоколов (то есть второго поля).

`head -n 5` выводит первые 5 строк из результата предыдущих команд. Таким образом, из отсортированного списка протоколов будут выбраны только пять первых строк.

```bash
103 pim
98 encap
94 ipip
89 ospf
81 vmtp
```

## **Задание №3**

```bash
#!/bin/bash

text=$*
length=${#text}

for i in $(seq 1 $((length + 2))); do
    line+="-"
done

echo "+${line}+"
echo "| ${text} |"
echo "+${line}+"
```

```bash
./script.sh "Hello, world!"
```

```bash
+---------------+
| Hello, world! |
+---------------+
```

Эта команда сохраняет все аргументы командной строки в переменную text. Переменная $* объединяет все аргументы в одну строку, разделенную пробелами.

Здесь вычисляется длина строки, содержащей все аргументы, и сохраняется в переменной length. Это делается с помощью ${#text}, который возвращает количество символов в переменной text.

`for i in  (seq1 ((length + 2))); do:`

Этот цикл `for` создаёт линию из символов `-`. Команда `seq 1 $((length + 2))` генерирует последовательность чисел от `1` до `(length + 2)`, где `length` — это длина текста, а `2` добавляется для учёта пробелов и символов `|` с обеих сторон текста.

## **Задание №4**

```bash
#!/bin/bash

file="$1"

id=$(grep -o -E '\b[a-zA-Z]*\b' "$file" | sort -u)
```
```bash
grep -oE '\b[a-zA-Z_][a-zA-Z0-9_]*\b' hello.c | grep -vE '\b(int|void|return|if|else|for|while|include|stdio)\b' | sort | uniq
count
i
main
printf
```

`file="$1":` Эта строка присваивает переменной `file` значение первого аргумента командной строки (путь к файлу). Таким образом, файл, который нужно обработать, передается в скрипт как аргумент.

`id= (grep−o−E′\b[a−zA−Z]∗\b′" file" | sort -u): grep -o -E '\b[a-zA-Z]\b' "$file": grep` — команда для поиска строк, соответствующих заданному регулярному выражению. Опция `-o` указывает, что нужно вывести только совпадения, а не всю строку. Опция `-E` включает использование расширенных регулярных выражений. Регулярное выражение `\b[a-zA-Z]\b` ищет слова, состоящие из символов латинского алфавита. Вот что это выражение означает: `\b` — граница слова. `[a-zA-Z]*` — любое количество (включая ноль) символов от "a" до "z" (как строчные, так и заглавные буквы).

В результате `grep` находит и выводит все слова (последовательности букв), присутствующие в файле.

## **Задание №5**

```bash
#!/bin/bash

file=$1

chmod 755 "./$file"

sudo cp "$file" /usr/local/bin/
```

```bash
./your-script.sh myscript.sh
myscript.sh
```

Команда `chmod 755` изменяет права доступа к файлу. В результате файл становится исполняемым для всех пользователей, но записывать его может только владелец.

Путь `"./$file"` означает, что изменяемые права относятся к файлу, находящемуся в текущей директории.

`sudo cp "$file" /usr/local/bin/:` Команда `cp` копирует файл в указанное место. В данном случае файл копируется в системный каталог `/usr/local/bin/`, который обычно используется для хранения исполняемых программ, доступных для всех пользователей системы. sudo используется для выполнения команды с правами администратора (так как обычный пользователь не имеет прав записи в `/usr/local/bin/`).